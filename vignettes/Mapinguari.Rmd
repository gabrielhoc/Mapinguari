---
title: "Mapinguari"
author: "Gabriel Caetano, Juan Santos, Barry Sinervo"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Mapinguari}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Mapinguari is an add-on package for program R, aimed at providing tools to facilitate the incorporation of biological processes in biogeographical analyses. It offers conveniences in fitting and comparing physiological models, as well as spatially extrapolating those models. The functions to model physiology offer enough flexibility to account for plasticity in physiology and microclimatic variation in the extrapolation. The package also allows to estimate geographical variation in the duration of phenological events, and summarize spatial data during these events. The spatial information generated using physiological and phenological models can then be used as predictors in species distribution modelling, for which Mapinguari offers tools for adequate evaluation, consensus, plotting and comparision, as well as utilities to deal with common pitfalls such as auto correlation in occurrence records and colinearity in spatial predictors.
	
It is well documented that climate change has severe effects on biodiversity. Species distribution modeling or SDM is a popular tool to predict individual species distributions and project the effects of these under diverse climate change models. Most SDMs are correlative and do not take into account biological processes underlying species responses to environmental variables. We aim to provide a modeling tool to fulfill this gap by estimating geographical layers with biologically relevant information that can be used in SDMs or other biogeographical analysis, as well as providing convenience and stimulating good practices for predictor selection and plotting. 

Mapinguari offers functions that facilitate the spatial extrapolation of models relating physiological measures of organisms, such as locomotor performance, metabolic and developmental rates or duration of activity to available spatialized information, such as climatic or geological variables. Those extrapolated values might function as an approximation of how well the organismâ€™s body works under those conditions, and therefore, might be relevant for informing about the species distribution under current and future conditions, specially climate, which is expected to change drastically in the near future, potentially affecting the ability of organisms to inhabit certain regions. This ecophysiological projections can be informative by themselves, but also complement traditional correlative methods.
		 
The timing and duration of specific events in the life of an organism can be crucial for its existence, such as breeding, flowering, fruiting or hibernating seasons. During those seasons, some organisms might become specially vulnerable to external conditions, which means the conditions during those times can be more informative of the ability of the organisms to remain in an area. Some of those events happen periodically and predictably, determined either by cycles inherent to the organism or by external inffluences. Mapinguari offers tools to predict the timing and duration of those events under different conditions, as well as gathering information about these and other conditions during those times. This feature can be combined with the physiological extrapolations, allowing further complexity in modelling.

The package is currently hosted on GitHub, this is how to install and load it:

```{r, message = FALSE, warning = FALSE}
# You need package devtools to install packages from GitHub
library(devtools)

install_github("gabrielhoc/Mapinguari")

library(Mapinguari)
```

Next, we are going to give an example of how to use the package, using some simulated data:

# The fate of *Fulanus*

*Fulanus beltranus* is a fictional species of lizard from Democratic Republic of Congo. We would like to find out how this species is going to do in different climate change scenarios. First let's look at the points where it is currently known to occurr. To access the table with distribution data `FulanusDistribution`, package Mapinguari has to be loaded. Here we use ggmap to plot the points over a image from Google Maps (copyright Google).

```{r, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 6}
library(Mapinguari)

# Load ggmap and ggplot2 to make the map
library(ggmap)
library(ggplot2)

Fulanus_bbox <- ggmap::make_bbox(lat = Lat, 
  lon = Lon, 
  data = FulanusDistribution,
  f = 0.2)

Fulanus_big <- ggmap::get_map(location = Fulanus_bbox, 
  source = "google", 
  maptype = "terrain")

ggmap::ggmap(Fulanus_big) +
  ggplot2::geom_point(data = FulanusDistribution, 
    mapping = ggplot2::aes(x = Lon, y = Lat), 
    size = 1, 
    colour = 'red')
```

First, let's get some information on the climate of this region.

# function get_rasters

How does the climate looks like in this area? We can use function `get_rasters` to extract WorldClim surfaces for that area. The argument `ext` tells us which is the area you desire to crop your rasters around. It accepts either a numerical vector with the coordinates of cropping limits (in order: western most longitude, easter most longitude, southern most latitude then northern most latitude), or a table of longitudes and latitudes, in which case it will grab the coordinates of the most extreme points and use those as the cropping limits. The argument `margin` adds to these limits, and it is on the same unit as the coordinates you supply.

```{r, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 6}
library('Mapinguari')

FulanusEcoRasters_present <-
   get_rasters(
     raster_source = "/Users/gabriel/Documents/Mapinguari/global_grids_10_minutes",
     ext = FulanusDistribution,
     margin = 5,
     non_fixed_var = c('prec', 'tmin', 'tmax'),
     fixed_var = 'alt',
     years = c("present"),
     reorder = TRUE)

raster::plot(FulanusEcoRasters_present[[1]])
```

`get_rasters` is able to download rasters from WorldClim, but you probably don't want to download them every time you are executing the function. That's why the argument `raster_source` will also take a list of rasters from your workspace or a path to a folder containing those rasters. These options also have the advantage of being able to input any raster you want, not being limited to the ones you can download from WorldClim.

However, in order for Mapinguari to recognize which variables correspond to each year or scenario, you have to name your folders and list elements following the convention *variable_year_scenario*. The default character for separating those terms is "_", but you can change that, as long as you do the corresponding change to the argument `separator` in the function. Some of your rasters will not be subject to scenarios, since they are measures of current climate, instead of projections. In that case you only have to name them *variable_year*, omitting the scenario term. The argument `baseline` identifies which years are not subject to scenarios. The default for this argument is `present`, but it can be changed at your convenience. Some other variables are constant accross time, such as altitude. In that case you only have to write the name of the variable. Here is an example of how my folder is structured:

![](/Users/gabriel/Documents/Mapinguari/vignettes/folder_organization.png)

I'm going to assign the path to that directory to an object:

```{r}
my_directory <- "/Users/gabriel/Documents/Mapinguari/global_grids_10_minutes"
```

Why did I place some variables in the `non-fixed` argument and others in the `fixed` argument? Well, that will become relevant once we start making future projections. Variables on `non_fixed` are things such as climate, which you expect to change in different times and future scenarios, while variables in `fixed` are things such as geological features, which you expect to remain constant accross the time projected.

Another important argument for non-fixed variables is `reorder`, which will take the last two characters of your RasterLayer names, replace letters with zeros and order the layers in ascending order of those numbers. This is useful because of the way some of the WorldClim layers are named when you download them, which when stacked will be placed out of chronological order. This argument fixes that. But be careful if you are using layers with different names than the ones from WorldClim. If they are in the correct order when you stack them, `reorder` could scramble them, so set it to FALSE.

Let's try doing some projections for the future years of 2050 and 2070:

```{r, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 6}
FulanusEcoRasters_future <-
   get_rasters(
     raster_source = my_directory,
     ext = FulanusDistribution,
     margin = 5,
     non_fixed_var = c('prec', 'tmin', 'tmax'),
     years = c('2050', '2070'),
     scenarios = c('rcp26', 'rcp45', 'rcp85'),
     reorder = TRUE)

raster::plot(FulanusEcoRasters_future$`2050_rcp26`)
```

As you can see, we have multiple rasters for each variable, one for each month. When doing biogeographical analysis, such as species distribution models, we are generally need a single raster for each variable, such as the annual average or total. Function `summarize_rasters` allows us to summarize time-varying rasters accross the year or parts of the year.

#summarize_rasters

Function `summarize_rasters` allows us to not only average, but also calculate standard deviations, totals, variance or any other summary function for the month layers. The argument `seasons` allows you to specify the months to be summarized. In this case, since we are interested in the whole year, but we can set `seasons` to a part of the year, or to multiple parts. Argument `summaryFUN` is where we specify the functions to be used for the summaries, and we can use a single function or specify multiple functions for different variables.

```{r, fig.height = 6, fig.width = 6}
Fulanus_present_year_summaries <-
   summarize_rasters(FulanusEcoRasters_present[[1]],
    seasons = list(year = c(1:12)),
    summaryFUN = list(tmax = c("mean", "sd"), tmin = c("mean", "sd"), prec = "sum"))

# The function operates in RasterStacks, if you want to apply it to a list, you can use `lapply`:

Fulanus_present_year_summaries_list <-   
lapply(FulanusEcoRasters_future, summarize_rasters,
    seasons = list(year = c(1:12)),
    summaryFUN = list(tmax = c("mean", "sd"), tmin = c("mean", "sd"), prec = "sum"))

# You can also specify multiple seasons

Fulanus_present_two_seasons_summaries <-
   summarize_rasters(FulanusEcoRasters_present[[1]],
    seasons = list(breeding = c(3:6), growing = c(8:11)),
    summaryFUN = list(tmax = c("mean", "sd"), tmin = c("mean", "sd"), prec = "sum"))

raster::plot(Fulanus_present_year_summaries$prec_year_sum)
raster::plot(Fulanus_present_two_seasons_summaries$prec_breeding_sum)
raster::plot(Fulanus_present_two_seasons_summaries$prec_growing_sum)
```

Now that we have information on the climate where the species live, let's get some information on the species physiology.

# function fit_curves

This function main goal is to create models of the relationship between a physiological measure and a environmental one, and output a vectorized function that is able to output the model prediction for any value inputed, so the physiological measures can be extrapolated to other environmental data, such as spatial or temporal data. It also evaluates the models, allowing the users to compare different parameterizations. This function is actually a wrapper around fitting functions specified by the user, which are defined in argument `fitFUN`. This can be any function that outputs a model that works with function `predict`, such as `glm` or `gamm` from package `mgcv`. You can get creative and use the functions for measures other than physiology. For example, you might want to fit a logisitic model of reproductive state against environment, which can be useful as an input for function `summarize_rasters`, as we will see later.

Back to *Fulanus*, we measured the maximum running speed of several individuals under different temperatures. We also recorded their body sizes, since that is a variable that is very likely to inffluence their performance. Here is how the data look like:

```{r}
head(FulanusPhysiology)
```

Note that we also attributed a number to each lizard to keep track of which lizard did which trial. That is important because, since the same lizard ran different trials, the data points are not independent and we have to account for that when building our model.

This table is inputed to `fit_curves` in the argument `data`, and the model parameterization is specified in argument `formula`. You can name the models by putting them on a named list. The function accepts any argument from the function specified in `fitFUN`, as long as they are inputed as a named list on argument `args_list`:

```{r}
library(mgcv)

# Here is an example without naming the models. They will be assigned a generic name.
perf_functions_no_name <-
  fit_curves(formula =  performance ~ s(temp, bs = 'cs') + size,
    data = FulanusPhysiology,
    fitFUN = gamm,
    args_list = list(random = list(id = ~ 1))
  )

# It is easier to keep track if you name them something meaningful (TPC means thermal performance curve)
perf_functions <-
  fit_curves(formula = list(tpc_gamm_size = performance ~ s(temp, bs = 'cs') + size),
    data = FulanusPhysiology,
    fitFUN = gamm,
    args_list = list(random = list(id = ~ 1))
  )
```

The function prints a table containing statitistics on each model, for comparison, and outputs a list containing that table, as well as a sub list for each model, containing the predictor function, raw model output and inputed arguments. You can assign the predictor function, which can be applied to any value.

```{r}
perf_functions$stats

perf_functions$tpc_gamm_size$predict
perf_functions$tpc_gamm_size$formula
perf_functions$tpc_gamm_size$output

my_tpc <- perf_functions$tpc_gamm_size$predict

my_tpc(temp = 20, size = 3)
my_tpc(temp = 20:40, size = 3)
```

The predictor function can be combined with the output from `get_rasters` or `summarize_rasters` to create a raster of physiology, which varies according to local environmental conditions. This is the subject of the next function, `trasform_rasters`. It is generally more efficient to apply `summarize_rasters` first, so the number of layers being estimated with `transform_rasters` is smaller, because this calculations can be very computationally intensive.

# transform_rasters

`transform_rasters` does the link between your physiological model and your spatial environmental data. It will apply any function to each year/scenario combination, as long as the variables necessary for the model are present. The predictor function is inputed on argument `transformFUN`. It doesn't have to be a function made by `fit_curves` necesesarily, any vectorized function should work. Sometimes you might name variables differently on your model and on your rasters, or you want flexibility to input different rasters forthe same model argument (for example, for temperature in a TPC, you might want to use either minimum or maximum temperatures). To deal with these situations, the argument `transformFUN_args` acts as a dictionary. It is a named list, in which the names are the variables in the model and the arguments are character strings of the variables in the rasters. You might also supply a numerical constant instead of a character string. That way, this variable will be set to that value for all calculations. That might be useful for example, if your model contain individual covariates such as body size, and you want to set a standard value for every calculation, for example, average body size. The name of the resulting layers can be specified by inputing a named list on argument `transformFUN`, so each predictor function will be associated with a name.

Note, however, that the variables on the rasters used have to be on the same scale as the data you used to fit the models. In this case, the raster temperatures are multiplied by 10, so we have to fix that first.

```{r, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 6}

# Let's scale the tmin and tmax average layers
FulanusEcoRasters_present_temps <- Fulanus_present_year_summaries[[c(2,4)]]/10

# You can calculate the performance for minimum and maximum temperatures, by changing the correspondence in ` transformFUN_args`

Perf_rasters_tmax <-
  transform_rasters(raster_stack = FulanusEcoRasters_present_temps,
    transformFUN = list(perf = my_tpc),
    transformFUN_args = list(temp = 'tmax', size = mean(FulanusPhysiology$size)),
    alert = 1)

Perf_rasters_tmin <-
  transform_rasters(raster_stack = FulanusEcoRasters_present_temps,
    transformFUN = list(perf = my_tpc),
    transformFUN_args = list(temp = 'tmin', size = mean(FulanusPhysiology$size)),
    alert = 2)

raster::plot(Perf_rasters_tmax[[1]][[1]])
raster::plot(Perf_rasters_tmin[[1]][[1]])
```

The function operates in RasterStacks, if you want to apply it to a list, you can use `lapply`:

```{r, eval = FALSE}
FulanusEcoRasters_future_temps <- lapply(FulanusEcoRasters_future, function(x) x[[13:36]]/10)

Perf_rasters_list <- lapply(FulanusEcoRasters_future_temps, transform_rasters,
  transformFUN = list(perf = my_tpc),
  transformFUN_args = list(temp = 'tmax', size = mean(FulanusPhysiology$size))
)
```

# integrating transform_rasters and summarize_rasters: spatial variation in phenology

Now, let's say the most crucial period for *Fulanus* population dynamics is their breeding period and they wil breed only under certain climatic conditions. This might cause their breeding period to vary spatially and temporally. In order to account for that, we can fit a logistic model of breeding status vs climate, using data from the table `FulanusBreeding`, which contain data on breeding status and climate at different localities. Then we can use this model to create binary rasters with the locations where Fulanus is breeding at each month, using function `transform_rasters`. After that, we can use the binary rasters as weights for a weighted mean calculated with `summarize_rasters`, and that should give us the mean of any raster during breeding season with spatial variation. Argument `summary_args` allow us to input extra arguments in the summary functions, including the weights needed

```{r, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 6}

Phen_model <- fit_curves(formula =  breeding ~ prec,
  data = FulanusBreeding, 
  fitFUN = glm,
  args_list = list(family = binomial(link = 'logit'))
 )

PhenFUN1 <- Phen_model$model_1$predict

season_rain_rasters <-
  transform_rasters(raster_stack = FulanusEcoRasters_present$present,
    transformFUN = list(season_rain = PhenFUN1),
    transformFUN_args = list(prec = 'prec'))

# Let's convert the raster to binary

season_rain_rasters_binary <-
  raster::calc(season_rain_rasters, function(x) ifelse(x < 0.5, 0, 1))

FulanusEcoRasters_season_rain <-
    summarize_rasters(Perf_rasters_tmax,
      seasons = list(year = c(1:12)),
      summaryFUN = "weighted.mean", 
      summary_args = list(weights = season_rain_rasters_binary))

# Length of Breeding season
raster::plot(sum(season_rain_rasters))

# Average Performance during breeding season
raster::plot(FulanusEcoRasters_season_rain)
```

```{r, fig.height = 6, fig.width = 6}

# The function can also be a condition. Let's say we are only interested on the periods when performance is bigger than 80.

PhenFUN2 <- function(x) ifelse(x > 80, 1, 0)

season_performance_rasters <-
  transform_rasters(raster_stack = FulanusEcoRasters_present$present,
    transformFUN = list(season_rain = PhenFUN2),
    transformFUN_args = list(prec = 'prec'))

FulanusEcoRasters_season_performance <-
    summarize_rasters(FulanusEcoRasters_present$present[[1:12]],
      seasons = list(year = c(1:12)),
      summaryFUN = "weighted.mean", 
      summary_args = list(weights = season_performance_rasters))

# Length of Breeding season
raster::plot(sum(season_performance_rasters))

# Average Performance during breeding season
raster::plot(FulanusEcoRasters_season_performance)

```

# An integrative example, calculating hours of activity

Coming soon.

Steps:
-get EVI or NDVI rasters
-Get EVI values for the coordinates of the locations in the table `FulanusMicroclimate` and add values to the table;
-Use `fit_curves` to make a model like `HA ~ temp + EVI` from `FulanusMicroclimate`;
-Use `transform_rasters` again to extrapolate HA.


```{r}

```
