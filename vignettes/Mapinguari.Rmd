---
title: "Mapinguari"
author: "Gabriel Caetano, Juan Santos, Barry Sinervo"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Mapinguari}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

	Mapinguari is an add-on package for program R, aimed at providing tools to facilitate the incorporation of biological processes in biogeographical analyses. It offers conveniences in fitting and comparing physiological models, as well as spatially extrapolating those models. The functions to model physiology offer enough flexibility to account for plasticity in physiology and microclimatic variation in the extrapolation. The package also allows to estimate geographical variation in the duration of phenological events, and summarize spatial data during these events. The spatial information generated using physiological and phenological models can then be used as predictors in species distribution modelling, for which Mapinguari offers tools for adequate evaluation, consensus, plotting and comparision, as well as utilities to deal with common pitfalls such as auto correlation in occurrence records and colinearity in spatial predictors.
	
		It is well documented that climate change has severe effects on biodiversity. Species distribution modeling or SDM is a popular tool to predict individual species distributions and project the effects of these under diverse climate change models. Most SDMs are correlative and do not take into account biological processes underlying species responses to environmental variables. We aim to provide a modeling tool to fulfill this gap by estimating geographical layers with biologically relevant information that can be used in SDMs or other biogeographical analysis, as well as providing convenience and stimulating good practices for predictor selection and plotting. 
		
		 Mapinguari offers functions that facilitate the spatial extrapolation of models relating physiological measures of organisms, such as locomotor performance, metabolic and developmental rates or duration of activity to available spatialized information, such as climatic or geological variables. Those extrapolated values might function as an approximation of how well the organismâ€™s body works under those conditions, and therefore, might be relevant for informing about the species distribution under current and future conditions, specially climate, which is expected to change drastically in the near future, potentially affecting the ability of organisms to inhabit certain regions. This ecophysiological projections can be informative by themselves, but also complement traditional correlative methods.
		 
		  The timing and duration of specific events in the life of an organism can be crucial for its existence, such as breeding, flowering, fruiting or hibernating seasons. During those seasons, some organisms might become specially vulnerable to external conditions, which means the conditions during those times can be more informative of the ability of the organisms to remain in an area. Some of those events happen periodically and predictably, determined either by cycles inherent to the organism or by external inffluences. Mapinguari offers tools to predict the timing and duration of those events under different conditions, as well as gathering information about these and other conditions during those times. This feature can be combined with the physiological extrapolations, allowing further complexity in modelling.

The package is currently hosted on GitHub, this is how to install and load it, as well as how to access this manual:

```{r}
# You need package devtools to install packages from GitHub
library(devtools)

install_github("gabrielhoc/Mapinguari")

library(Mapinguari)
```

Next, we are going to give an example of how to use the package, using some simulated data:

# The fate of *Fulanus*

*Fulanus beltranus* is a fictional species of lizard from Democratic Republic of Congo. We would like to find out how this species is going to do in different climate change scenarios. First let's look at the points where it is currently known to occurr. To access the table with distribution data `FulanusDistribution`, package Mapinguari has to be loaded. Here we use ggmap to plot the points over a image from Google Maps (copyright Google).

```{r, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 6}
# Load ggmap and ggplot2 to make the map
library(ggmap)
library(ggplot2)

Fulanus_bbox <- ggmap::make_bbox(lat = Lat, 
  lon = Lon, 
  data = FulanusDistribution,
  f = 0.2)

Fulanus_big <- ggmap::get_map(location = Fulanus_bbox, 
  source = "google", 
  maptype = "terrain")

ggmap::ggmap(Fulanus_big) +
  ggplot2::geom_point(data = FulanusDistribution, 
    mapping = ggplot2::aes(x = Lon, y = Lat), 
    size = 1, 
    colour = 'red')
```

First, let's get some information on the climate of this region.

# function get_rasters

How does the climate looks like in this area? We can use function `get_rasters` to extract WorldClim surfaces for that area. The argument `ext` tells us which is the area you desire to crop your rasters around. It accepts either a numerical vector with the coordinates of cropping limits (in order: western most longitude, easter most longitude, southern most latitude then northern most latitude), or a table of longitudes and latitudes, in which case it will grab the coordinates of the most extreme points and use those as the cropping limits. The argument `margin` adds to these limits, and it is on the same unit as the coordinates you supply.

```{r, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 6}
library('Mapinguari')

FulanusEcoRasters_present <-
   get_rasters(
     raster_source = "/Users/gabriel/Documents/Mapinguari/global_grids_10_minutes",
     ext = FulanusDistribution,
     margin = 5,
     non_fixed_var = c('prec', 'tmin', 'tmax'),
     fixed_var = 'alt',
     years = c("present"),
     reorder = TRUE)

raster::plot(FulanusEcoRasters_present[[1]])
```

`get_rasters` is able to download rasters from WorldClim, but you probably don't want to download them every time you are executing the function. That's why the argument `raster_source` will also take a list of rasters from your workspace or a path to a folder containing those rasters. These options also have the advantage of being able to input any raster you want, not being limited to the ones you can download from WorldClim.

However, in order for Mapinguari to recognize which variables correspond to each year or scenario, you have to name your folders and list elements following the convention *variable_year_scenario*. The default character for separating those terms is "_", but you can change that, as long as you do the corresponding change to the argument `separator` in the function. Some of your rasters will not be subject to scenarios, since they are measures of current climate, instead of projections. In that case you only have to name them *variable_year*, omitting the scenario term. The argument `baseline` identifies which years are not subject to scenarios. The default for this argument is `present`, but it can be changed at your convenience. Some other variables are constant accross time, such as altitude. In that case you only have to write the name of the variable. Here is an example of how my folder is structured:

image: ![](/Users/gabriel/Documents/Mapinguari/vignettes/folder_organization.png)

I'm going to assign the path to that directory to an object:

```{r}
my_directory <- "/Users/gabriel/Documents/Mapinguari/global_grids_10_minutes"
```

Why did I place some variables in the `non-fixed` argument and others in the `fixed` argument? Well, that will become relevant once we start making future projections. Variables on `non_fixed` are things such as climate, which you expect to change in different times and future scenarios, while variables in `fixed` are things such as geological features, which you expect to remain constant accross the time projected.

Another important argument for non-fixed variables is `reorder`, which will take the last two characters of your RasterLayer names, replace letters with zeros and order the layers in ascending order of those numbers. This is useful because of the way some of the WorldClim layers are named when you download them, which when stacked will be placed out of chronological order. This argument fixes that. But be careful if you are using layers with different names than the ones from WorldClim. If they are in the correct order when you stack them, `reorder` could scramble them, so set it to FALSE.

Let's try doing some projections for the future years of 2050 and 2070:

```{r, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 6}
FulanusEcoRasters_future <-
   get_rasters(
     raster_source = my_directory,
     ext = FulanusDistribution,
     margin = 5,
     non_fixed_var = c('prec', 'tmin', 'tmax'),
     years = c('2050', '2070'),
     scenarios = c('rcp26', 'rcp45', 'rcp85'),
     reorder = TRUE)

raster::plot(FulanusEcoRasters_future$`2050_rcp26`)
```

Now that we have information on the climate where the species live, let's get some information on the species physiology.

# function fit_curves

This function main goal is to create models of the relationship between a physiological measure and a environmental one, and output a vectorized function that is able to output the model prediction for any value inputed, so the physiological measures can be extrapolated to other environmental data, such as spatial or temporal data. It also evaluates the models, allowing the users to compare different parameterizations. This function is actually a wrapper around fitting functions specified by the user, which are defined in argument `fitFUN`. This can be any function that outputs a model that works with function `predict`, such as `glm` or `gamm` from package `mgcv`. You can get creative and use the functions for measures other than physiology. For example, you might want to fit a logisitic model of reproductive state against environment, which can be useful as an input for function `summarize_rasters`, as we will see later.

Back to *Fulanus*, we measured the maximum running speed of several individuals under different temperatures. We also recorded their body sizes, since that is a variable that is very likely to inffluence their performance. Here is how the data look like:

```{r}
head(FulanusPhysiology)
```

Note that we also attributed a number to each lizard to keep track of which lizard did which trial. That is important because, since the same lizard ran different trials, the data points are not independent and we have to account for that when building our model.

This table is inputed to `fit_curves` in the argument `data`, and the model parameterization is specified in argument `formula`. You can name the models by putting them on a named list. The function accepts any argument from the function specified in `fitFUN`, as long as they are inputed as a named list on argument `args_list`:

```{r}
library(mgcv)

# Here is an example without naming the models. They will be assigned a generic name.
perf_functions_no_name <-
  fit_curves(formula =  performance ~ s(temp, bs = 'cs') + size,
    data = FulanusPhysiology,
    fitFUN = gamm,
    args_list = list(random = list(id = ~ 1))
  )

# It is easier to keep track if you name them something meaningful (TPC means thermal performance curve)
perf_functions <-
  fit_curves(formula = list(tpc_gamm_size = performance ~ s(temp, bs = 'cs') + size),
    data = FulanusPhysiology,
    fitFUN = gamm,
    args_list = list(random = list(id = ~ 1))
  )
```

The function prints a table containing statitistics on each model, for comparison, and outputs a list containing that table, as well as a sub list for each model, containing the predictor function, raw model output and inputed arguments. You can assign the predictor function, which can be applied to any value.

```{r}
perf_functions$stats

perf_functions$tpc_gamm_size$predict
perf_functions$tpc_gamm_size$formula
perf_functions$tpc_gamm_size$output

my_tpc <- perf_functions$tpc_gamm_size$predict

my_tpc(temp = 20, size = 3)
my_tpc(temp = 20:40, size = 3)
```

The predictor function can be combined with the output from `get_rasters` to create a raster of physiology, which varies according to local environmental conditions. This is the subject of the next function, `trasform_rasters`.

# transform_rasters

`transform_rasters` does the link between your physiological model and your spatial environmental data. It will apply any function to each year/scenario combination, as long as the variables necessary for the model are present. The predictor function is inputed on argument `transformFUN`. It doesn't have to be a function made by `fit_curves` necesesarily, any vectorized function should work (hopefully). Sometimes you might name variables differently on your model and on your rasters, or you want flexibility to input different rasters forthe same model argument (for example, for temperature in a TPC, you might want to use either minimum or maximum temperatures). To deal with these situations, the argument `transformFUN_args` acts as a dictionary. It is a named list, in which the names are the variables in the model and the arguments are character strings of the variables in the rasters. You might also supply a numerical constant instead of a character string. That way, this variable will be set to that value for all calculations. That might be useful for example, if your model contain individual covariates such as body size, and you want to set a standard value for every calculation, for example, average body size. The name of the resulting layers can be specified by inputing a named list on argument `transformFUN`, so each predictor function will be associated with a name.

```{r, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 6}
# You can calculate the performance for minimum and maximum temperatures, by changing the correspondence in ` transformFUN_args`

Perf_rasters_tmax <-
  transform_rasters(raster_stack = FulanusEcoRasters_present[[1]],
    transformFUN = list(perf = my_tpc),
    transformFUN_args = list(temp = 'tmax', size = mean(FulanusPhysiology$size)))

Perf_rasters_tmin <-
  transform_rasters(raster_stack = FulanusEcoRasters_present[[1]],
    transformFUN = list(perf = my_tpc),
    transformFUN_args = list(temp = 'tmin', size = mean(FulanusPhysiology$size)))

raster::plot(Perf_rasters_tmax[[1]][[1]])
```

The function operates in RasterStacks, if you want to apply it to a list, you can use `lapply`:

```{r}
Perf_rasters_list <- lapply(FulanusEcoRasters_future, transform_rasters,
  transformFUN = list(perf = my_tpc),
  transformFUN_args = list(temp = 'tmax', size = mean(FulanusPhysiology$size))
)
```

Function `transform_rasters` is computationally intensive, but it can be parallelized. Another way to reduce the amount of time needed is to reduce the number of rasters in the calculation. So far we have been applying `transform_rasters` to RasterStacks with 12 layers for each variable, one for each month. If you are interested, for example, in the average year performance, it is more efficient to average all 12 month layers and then apply `transform_rasters` to the resulting average layer, which can be done with function `summarize_rasters`

#summarize_rasters

Function `summarize_rasters` allows us to not only average, but also calculate standard deviations, totals, variance or any other summary function for the month layers. The argument `seasons` allows you to specify the months to be summarized. In this case, since we are interested in the whole year, but we can set `seasons` to a part of the year, or to multiple parts.

```{r}
Fulanus_present_year_summaries <-
   summarize_rasters(Fulanus_Ecorasters_present[[1]],
    seasons = list(year = c(1:12)),
    summaryFUN = list(tmax = c("mean", "sd"), tmin = c("mean", "sd"), prec = "sum"))

# Like `transform_rasters`, you can apply `summarize_rasters` over a list using lapply
Fulanus_present_year_summaries <-   
lapply(Fulanus_Ecorasters_future, summarize_rasters,
    seasons = list(year = c(1:12)),
    summaryFUN = list(tmax = c("mean", "sd"), tmin = c("mean", "sd"), prec = "sum"))

Fulanus_present_year_summaries <-
   summarize_rasters(Fulanus_Ecorasters_present[[1]],
    seasons = list(breeding = c(3:6), growing = c(8:11)),
    summaryFUN = list(tmax = c("mean", "sd"), tmin = c("mean", "sd"), prec = "sum"))
```

Now, let's say the most crucial period for *Fulanus* population dynamics is their breeding period and they wil breed only under certain climatic conditions. This might cause their breeding period to vary spatially and temporally. In order to account for that, function `summarize_rasters` can take other functions in argument `seasons`, which will take the environmental surfaces supplied as arguments and decide based on the values for each pixel in each raster if it is included in that season or not. This allows spatial variation in the seasons. `summarize_rasters` also has a `season_args` argument, which works as translation between function arguments and raster names, in the same way as `transformFUN_args` described above

```{r, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 6}

# Let's try first with a logistic function
# Fix this later: simulate data on breeding seasons and environmental conditions, then fit this model

PhenFUN1 <- function(x) round(1/(1 + exp((150 - x)/2)), 2)

Seasons_by_rain <-
    lapply(FulanusEcoRasters_future, summarize_rasters,
      seasons = list(breeding = PhenFUN1),
      seasons_args = list(x = 'prec'),
      summaryFUN = "mean")

# a new `season_length` layer will be created, with the duration of the season.

raster::plot(Seasons_by_rain$present$season_length)
raster::plot(Seasons_by_rain$present$tmax_breeding_mean)
```

```{r, fig.height = 6, fig.width = 6, eval = FALSE}

# The function can also be a condition. Let's say we are only interested on the periods when performance is bigger than 80.

PhenFUN2 <- function(x) ifelse(x > 80, 1, 0)

Seasons_by_performance <-
  lapply(Perf_rasters_tmax, 
    summarize_rasters,
    seasons = list(breeding = PhenFUN2) ,
    season_args = list(x = 'perf'))

raster::plot(Seasons_by_performance$present$season_length)
raster::plot(Seasons_by_performance$present$perf_breeding)

```

We haven't input anything on `summaryFUN`! If that happens, the function will return the result of the function in `seasons` for each month, in our case, it will show the areas that allow breeding for every month. What the function does is generate these rasters, multiplies then by the corresponding rasters for the other variables in that month, then applies the function in `summaryFUN`. While that might be work well with some functions, like `sum`, it does not make sense to do it with `mean`, since the proportion resulted from the function in `seasons` is not accounted for in the operation. For us to get an accurate average, given spatial variation in season, we would need a `weighted.mean`. That is a summary function that needs additional arguments, the weights. To input additional arguments for summary functions, we use argument `summaryFUN_args`

Note that the season by performance maps have blank spots both in the Season and NonSeason rasters, while the season by rain maps have blank spots only on the Season raster. Why is that? Let's look at the values for the season length at the present for both the `Seasons_by_rain` and `Seasons_by_performance`.

```{r}
Seasons_by_rain$present$season_length
Seasons_by_performance$present$season_length
```

You can see that the season by rain raster ranges from 0 to 9, that means that the species is unable to breed in some places, and the places where it breeds for longer, the breeding season lasts 9 months. While the season by performance raster ranges from 0 to 12, that means there are places where the species can't breed and places where the species can breed all year long. That shows on the map as the blank spots. If the values are 0 on the Season raster, it means the species can't breed in that location, if they are 0 in the NonSeason raster, it means they breed all year long in that location.
